## 一 算法框架

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。

代码方面，回溯算法的框架：

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**，特别简单。

什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！

## 二 问题举例

### 1.全排列问题

我们在高中的时候就做过排列组合的数学题，我们也知道 `n` 个不重复的数，全排列共有 n! 个。

PS：**为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字**。

那么我们当时是怎么穷举全排列的呢？比方说给三个数 `[1,2,3]`，你肯定不会无规律地乱穷举，一般是这样：

先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……

其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：

![image-20201223092051457](https://gitee.com/zisuu/picture/raw/master/img/20201223092051.png)

只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。**我们不妨把这棵树称为回溯算法的「决策树」**。

**为啥说这是决策树呢，因为你在每个节点上其实都在做决策**

**现在可以解答开头的几个名词：****`[2]`** **就是「路径」，记录你已经做过的选择；****`[1,3]`** **就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候**。

如果明白了这几个名词，**可以把「路径」和「选择」列表作为决策树上每个节点的属性**，比如下图列出了几个节点的属性：

![image-20201223092140098](https://gitee.com/zisuu/picture/raw/master/img/20201223092140.png)

**我们定义的** **`backtrack`** **函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列**。

回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：

![image-20201223092229684](https://gitee.com/zisuu/picture/raw/master/img/20201223092229.png)

现在，你是否理解了回溯算法的这段核心框架？



```
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。

下面，直接看全排列代码：

```c++
vector<vector<int>> result;
vector<int> vis;
void dfs(vector<int> nums,vector<int> track,int cur)
{
    //边界
    if(cur==nums.size())
    {
        result.push_back(track);
        return;
    }
    if(cur>=nums.size())return;
    //选择列表
    for(int i=0;i<nums.size();i++)
    {
        if(!vis[i])
        {
            //做出选择
            vis[i]=true;
            track.push_back(nums[i]);
            dfs(nums,track,cur+1);
            //回朔
            vis[i]=false;
            track.pop_back();
        }
    }
}
vector<vector<int>> permute(vector<int>& nums) {
    int size=nums.size();
    vis=vector<int>(size,false);
    dfs(nums,vector<int>{},0);
    return result;
}
```

### 2.N皇后问题

这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。

**PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。**

这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。

直接套用框架:



```c++
int size;
vector<vector<string>> result;
bool isValid(int row,int col,vector<int> colIndex)
{
    for(int i=0;i<row;i++)
    {
        if(colIndex[i]==col|| i-colIndex[i]==row-col||i+colIndex[i]==row+col)
            return false;
    }
    return true;
}
/**
 * 
 * @param board  记录棋盘
 * @param colIndex 记录每行的列数
 * @param row 当前行
 */
void dfs(vector<string> board,vector<int> colIndex,int row)
{
    //边界
    if(row == size)
    {
        result.push_back(board);
    }
    if(row >= size)
        return;
    //选择列表
    for (int i = 0; i < size; ++i) {
        if(isValid(row,i,colIndex))
        {
            //选择
            board[row][i]='Q';
            colIndex[row]=i;
            dfs(board,colIndex,row+1);
            //回朔
            colIndex[row]=-1;
            board[row][i]='.';
        }
    }
}
vector<vector<string>> solveNQueens(int n) {
    size=n;
    vector<string> board(n,string(n,'.'));
    dfs(board,vector<int>(n,-1),0);
    return result;
}
```

## 三 分类题型

### 1.排列,组合类型

#### 1.[全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

![image-20201223102128058](https://gitee.com/zisuu/picture/raw/master/img/20201223102128.png)

我们先画出递归树:

![image-20201223104847780](https://gitee.com/zisuu/picture/raw/master/img/20201223104848.png)

```c++
class Solution {
public:
vector<vector<int>> result;
vector<bool> flag;
vector<int> num;
void dfs( vector<int> arr,int cur){
    if(cur==num.size()){
        result.push_back(arr);
    }
    if(cur>=num.size())return;
    for (int i = 0; i < num.size() ; ++i) {
        if( i>0 && num[i]==num[i-1]&& ! flag[i-1])continue;
        if(!flag[i]){
            flag[i]= true;
            arr.push_back(num[i]);
            dfs(arr,cur+1);
            arr.pop_back();
            flag[i]= false;
        }
    }
}
vector<vector<int>> permuteUnique(vector<int>& nums) {
    num=nums;
        sort(num.begin(),num.end());
    int size=nums.size();
    flag=vector<bool>(size, false);
    dfs({},0);
    return result;
}
};
```



#### 2.[子集](https://leetcode-cn.com/problems/subsets/)

![image-20201223100519306](https://gitee.com/zisuu/picture/raw/master/img/20201223100519.png)

该回朔算法的递归树:

![image-20201223101137664](https://gitee.com/zisuu/picture/raw/master/img/20201223101137.png)

据此,我们需要一个指针cur,选择列表只能从cur开始往后

```c++
class Solution {
public:
vector<vector<int>> result;
void dfs(vector<int>nums,vector<int> temp,int cur){
    result.push_back(temp);
    for(int i=cur;i<nums.size();i++){
        temp.push_back(nums[i]);
        dfs(nums,temp,i+1);
        temp.pop_back();
    }
}
vector<vector<int>> subsets(vector<int>& nums) {
    if(nums.size()==0)return result;
    dfs(nums,vector<int>{},0);
    return result;
}
};
```



#### 3.[组合](https://leetcode-cn.com/problems/combinations/)

![image-20201223101500369](https://gitee.com/zisuu/picture/raw/master/img/20201223101500.png)

![image-20201223101547751](https://gitee.com/zisuu/picture/raw/master/img/20201223101547.png)

这题和子集的区别在于需要判断边界而已

```
vector<vector<int>> result;
void dfs(vector<int> nums,int cur,int n,int k)
{
    if(nums.size()==k)
    {
        result.push_back(nums);
    }
    if(nums.size()>=k)
        return;
    for(int i=cur;i<=n;i++)
    {
        nums.push_back(i);
        dfs(nums,i+1,n,k);
        nums.pop_back();
    }
}
vector<vector<int>> combine(int n, int k) {
    dfs(vector<int>{},1,n,k);
    return result;
}
```



### 2.[解数独](https://leetcode-cn.com/problems/sudoku-solver/):返回一次类型

![image-20201223105035830](https://gitee.com/zisuu/picture/raw/master/img/20201223105035.png)

这题看似很难,但其实和前面的回朔没有太大的区别

我们先整理以下思路:

我们想要在盘中的(i,j)这个点填数字num,并且num要有要求:

- 同一行不能重复  也即row(i,num)==0
- 同一列不能重复   也即col(j,num)==0
- 同一个3*3的格子不能重复 也即 box(j/3+(i/3)*3)==0

最后,我们只需要一个解即可,所以在做出决策的回朔时需要这样判断:

```
if(dfs(xxxx))
	return true;
```

最后代码:

```c++
class Solution {
public:
int row[10][10]={0};
int col[10][10]={0};
int box[10][10]={0};
int m,n;
bool isOk(int i,int j,int val){
    return i>=0&&i<m&&j>=0&&j<n&&!row[i][val]&&!col[j][val]&&!box[j/3+(i/3)*3][val];
}
bool dfs(vector<vector<char>>& board,int i,int j){
    //边界就是换行即可
    if(j==n){
        j=0;
        i++;
        if(i==n)return true;
    }
    if(board[i][j]=='.'){
        for (int k = 1; k <=9 ; ++k) {
            if(isOk(i,j,k)){
                board[i][j]=k+'0';
                row[i][k]=1;
                col[j][k]=1;
                box[j/3+(i/3)*3][k]=1;
                //注意这里,只返回一个解即可
                if(dfs(board,i,j+1))return true;
                board[i][j]='.';
                row[i][k]=0;
                col[j][k]=0;
                box[j/3+(i/3)*3][k]=0;
            }
        }
    }else{
        return dfs(board,i,j+1);
    }
    return false;
}
void solveSudoku(vector<vector<char>>& board) {
    m=n=9;
    //先预设值
    for (int i = 0; i <m ; ++i) {
        for (int j = 0; j <n ; ++j) {
            if(board[i][j]!='.'){
                int val=board[i][j]-'0';
                row[i][val]=1;
                col[j][val]=1;
                box[j/3+(i/3)*3][val]=1;
            }
        }
    }
    dfs(board,0,0);
}
};
```



