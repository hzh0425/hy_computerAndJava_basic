## ä¸€  æ·±åº¦ä¼˜å…ˆæœç´¢

### ä¸€ å›æœ”ç±»å‹

#### [1.24 ç‚¹æ¸¸æˆ](https://leetcode-cn.com/problems/24-game/)

![image-20201226151018641](https://gitee.com/zisuu/picture/raw/master/img/20201226151018.png)

çœ‹åˆ°è¿™ç§é¢˜ç›®,ç¬¬ä¸€ååº”æ˜¯:å¥½éš¾!

ä½†å…¶å®,æˆ‘ä»¬è¦åšå¾—æ— éæ˜¯æš´åŠ›æšä¸¾,æ€ä¹ˆæšä¸¾å‘¢?ç”»å‡ºå†³ç­–æ ‘:

(æ¯”å¦‚ä»8å¼€å§‹,è¿™é‡Œåªåˆ—ä¸¾äº†+å’Œ-,å…·ä½“å¯ä»¥ç”»ä¸€ä¸‹Ã—å’ŒÃ·)

![](https://gitee.com/zisuu/picture/raw/master/img/20201226151656.png)

å†³ç­–æ ‘è¿™å°±æ˜¯å›æœ”å¾—è¿‡ç¨‹,ä¹Ÿå³æ¯æ¬¡æšä¸¾ä¸¤ä¸ªæ•°,å°è¯•å››ç§è¿ç®—,å†é€’å½’,å†å›æœ”å³å¯

æ¡†æ¶:

```c++
bool dfs(vector<int>nums)
{
    //è¾¹ç•Œ
    if()
        ////
    for(int i=0;i<nums.size();i++){
        for(int j=0;j<nums.size();j++){
            if(i!=j){
                vector<int> temp;//å­˜æ”¾numsä¸­é™¤äº†i,jä¸‹æ ‡å¾—åˆ«çš„æ•°æ®
                /......./
                //åŠ 
                temp.push_back(nums[i]+nums[j]);
                if(dfs(temp))
                    return true;
                temp.pop_back();
                //å‡
                temp.push_back(nums[i]-nums[j]);
                if(dfs(temp))
                    return true;
                temp.pop_back();
                //ä¹˜,é™¤
                .....
            }
        }
    }
}
```

```c++
class Solution {
public:
    bool dfs(vector<double>nums)
    {
        if(nums.size()==1)
        {
            return fabs(nums[0]-24)<1e-6;
        }
        for(int i=0;i<nums.size();i++)
        {
            for(int j=0;j<nums.size();j++)
            {
                if(i==j)
                    continue;
                vector<double> temp;
                double n1=nums[i];
                double n2=nums[j];
                for(int k=0;k<nums.size();k++)
                {
                    if (k!=i&&k!=j)
                        temp.push_back((double)nums[k]);
                }
                for(int type=0;type<4;type++)
                {
                
                    if(type==0)
                        temp.push_back(n1+n2);
                    if(type==1)
                        temp.push_back(n1-n2);
                    if(type==2)
                        temp.push_back(n1*n2);
                    if(type==3)
                    {
                        if(n2!=0)
                            temp.push_back(n1/n2);
                        else
                            continue;
                    }
                    if(dfs(temp))
                        return true;
                    temp.pop_back();
                }
            }
        }
        return false;
    }
    bool judgePoint24(vector<int>& nums) {
        vector<double> n;
        for(auto k:nums)
            n.push_back((double)k*1.0);
        return dfs(n);
    }
};
```

#### 2.[æ‰€æœ‰å¯èƒ½çš„è·¯å¾„](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

![image-20201227113512998](https://gitee.com/zisuu/picture/raw/master/img/20201227113513.png)

è¿˜æ˜¯ä¸€æ ·çš„è€å¥—è·¯,ç”»å†³ç­–æ ‘å°±ä¼šæœ‰ç­”æ¡ˆ

```c++
class Solution {
public:
vector<vector<int>> result;
vector<bool> flag;
int target;

void dfs(vector<int> arr,int i,vector<vector<int>>& graph){
    flag[i]= true;
    if(i==target){
        result.push_back(arr);
        return;
    }
    if(arr.size()>target+1)return;
    for (int j = 0; j <graph[i].size(); ++j) {
            arr.push_back(graph[i][j]);
            dfs(arr,graph[i][j],graph);
            arr.pop_back();
    }
}
vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
    int size=graph.size();
    target=size-1;
    flag=vector<bool>(size+1, false);
    dfs(vector<int>{0},0,graph);
    return result;
}
};
```

#### 3.[ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![image-20201227114635634](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20201227114635634.png)

å†³ç­–æ ‘å¦‚ä¸‹:

![image-20201227114628467](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20201227114628467.png)

```c++
#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
	vector<string> result;
	vector<string> num={"","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
	void dfs(string digit,int cur,string temp)
	{
		if(temp.size()==digit.size())
		{
			result.push_back(temp);
			return;
		}
		for(int i=cur;i<digit.size();i++)
		{
			int index=digit[i]-'0'-1;
			for(int j=0;j<num[index].size();j++)
			{
				temp.push_back(num[index][j]);
				dfs(digit,i+1,temp);
				temp.pop_back();
			}
		}
	}
    vector<string> letterCombinations(string digits) {
    	if(digits=="")
    		return result;
    	dfs(digits,0,"");
    	return result;
    }
};
```



#### [4.ç«æŸ´æ‹¼æ­£æ–¹å½¢](https://leetcode-cn.com/problems/matchsticks-to-square/)

![image-20201227115558719](https://gitee.com/zisuu/picture/raw/master/img/20201227115558.png)\

è¿™é¢˜ç‚¸ä¸€çœ‹å’Œ24ç‚¹æ¸¸æˆå¾ˆçœ‹,å†è¿›ä¸€æ­¥æƒ³

æˆ‘ä»¬çš„æœ€ç»ˆç›®çš„æ˜¯ä¸ºäº†å¾—åˆ°å››æ¡è¾¹,æ‰€ä»¥æ— éœ€åƒ24ç‚¹é‚£æ ·æšä¸¾æŸä¸¤æ¡è¾¹ç›¸åŠ 

è€Œæ˜¯ç›´æ¥æšä¸¾å°†å½“ç‚¹è¡¨åŠ å…¥åˆ°å››æ¡è¾¹ä¸­çš„æŸä¸€æ¡:

å¦‚ä¸‹:

![image-20201227120446635](https://gitee.com/zisuu/picture/raw/master/img/20201227120446.png)



```c++
class Solution {
public:
    bool makesquare(vector<int>& nums) {
       //ä¼˜åŒ–ä¸€,å…ˆæ’åº
        sort(nums.begin(), nums.end(), greater<int>());
        auto sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 4 != 0 || nums.size() < 4) {
            return false;
        }

        int target = sum / 4;
        vector<int> side(4, 0);
        return backtrack(nums, 0, target, side);
    }

private:
    bool backtrack(vector<int>& nums, int start, int target, vector<int>& side) {
        if (start == nums.size()) {
            // This implies 4 sides all each to target, since target = sum / 4
            return (side[0] == side[1] && side[1] == side[2] && side[2] == side[3]);
        }

        // Try to use stick nums[start] in this round, no need to loop nums[i],
        // keep increase start in every level should be enough
        for (int i = 0; i < 4; i++) {
        	//ä¼˜åŒ–äºŒ
            if (side[i] + nums[start] > target) {
                continue;
            }

            // Make choice
            side[i] += nums[start];
            if (backtrack(nums, start + 1, target, side)) {
                return true;
            }
            // Undo choice
            side[i] -= nums[start];
        }

        return false;
    }
};
```



## äºŒ å¹¿åº¦ä¼˜å…ˆæœç´¢

### ä¸€ æš´åŠ›bfsæœç´¢ç±»å‹

#### [1. å…¬äº¤è·¯çº¿](https://leetcode-cn.com/problems/bus-routes/)

![image-20201227194627772](https://gitee.com/zisuu/picture/raw/master/img/20201227194627.png)

åˆ©ç”¨bfsæ€è·¯:

![image-20201227194915831](https://gitee.com/zisuu/picture/raw/master/img/20201227194915.png)

ä¹Ÿå³ä»startå¼€å§‹,ä¸€å±‚ä¸€å±‚å¾€å¤–éå†ä¸€é,

ç›¸å½“äºæ¯ä¸ªç«™ç‚¹,åªè¦å®ƒåœ¨ä¸€ä¸ªè·¯çº¿å†…,å°±å¯ä»¥éå†è·¯çº¿å†…çš„æ‰€æœ‰ç«™ç‚¹,

å¦‚,1åœ¨è·¯çº¿route[0]å†…,å®ƒå¯ä»¥éå†2å’Œ7

åŒç†,å½“åˆ°7æ—¶,è‡ªç„¶è€Œç„¶å¯ä»¥éå†3å’Œ6

æ‰€ä»¥,æˆ‘ä»¬éœ€è¦çŸ¥é“æ¯ä¸ªç«™ç‚¹åœ¨å“ªäº›ä¸ªè·¯çº¿å†…,è¿™æ ·æ‰èƒ½éå†è·¯çº¿å†…çš„æ¯ä¸ªç«™ç‚¹

å¦å¤–,æˆ‘ä»¬è¦å°†è·¯çº¿çš„ä¸‹æ ‡å‹å…¥é˜Ÿåˆ—,è€Œä¸æ˜¯ç«™ç‚¹å‹å…¥é˜Ÿåˆ—,

ä¹Ÿå³æˆ‘ä»¬æ¯æ¬¡ä»é˜Ÿåˆ—ä¸­å–å‡ºå…ƒç´ å,è¦éå†çš„æ˜¯ä¸€æ•´ä¸ªè·¯çº¿ä¸­çš„æ‰€æœ‰ç«™ç‚¹çš„æ‰€æœ‰æ‰€å±è·¯çº¿

```c++
class Solution{
public:
    int numBusesToDestination(vector<vector<int>>& routes, int S, int T) {
        if (S == T) return 0;
        int N = routes.size();
        map<int, set<int> > m; // å­˜å‚¨è½¦ç«™èƒ½é€šåˆ°å“ªäº›è·¯çº¿
        for (int i = 0; i < N; ++i) {
            for (auto j : routes[i]) {
                m[j].insert(i);
            }
        }
        vector<bool> visited(N, false); // å“ªäº›è·¯çº¿è¢«éå†è¿‡äº†
        queue<int> q; // å­˜å‚¨å·²ç»éå†è¿‡çš„è·¯çº¿
        for (auto x : m[S]) {
            q.push(x);
            visited[x] = true;
        }
        int step = 0;
        while (!q.empty()) {
            ++step;
            int s = q.size();
            for (int i = 0; i < s; ++i) {
                int t = q.front();
                q.pop();
                for (auto j : routes[t]) {
                    if (j == T) return step;
                    for (auto x : m[j]) {
                        if (!visited[x]) {
                            q.push(x);
                            visited[x] = true;
                        }
                    }
                }
            }
        }
        return -1;
    }
};

```

#### 2.[ é€ƒç¦»å¤§è¿·å®«](https://leetcode-cn.com/problems/escape-a-large-maze/)

![image-20201228150457119](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20201228150457119.png)

![image-20201228150736281](https://gitee.com/zisuu/picture/raw/master/img/20201228150736.png)



1.è¿™é¢˜è™½ç„¶çœ‹èµ·æ¥å°±æ˜¯æ ‡å‡†çš„bfsæ¨¡æ¿,ä½†å¦‚æœç”¨æ•°ç»„æ¥ä¿å­˜å·²ç»è®¿é—®è¿‡çš„,å‘ç°x,y=1e6

å¼€æ•°ç»„ä¼šçˆ†æ ˆ

è§£å†³æ–¹æ³•:å­—ç¬¦ä¸²å‹ç¼©

ä¹Ÿå³æŠŠx,yå˜ä¸º x:y è¿™ç§å­—ç¬¦ä¸²æ”¾å…¥setä¸­

2.å¦å¤–,è¿™é¢˜è¿˜å¯ä»¥è¿›è¡Œä¼˜åŒ–

å› ä¸ºblockå¤§å°ä¸è¶…è¿‡200,æœ€å¤§èƒ½å›´çš„èŒƒå›´æ˜¯:

1+2+...+200 ~=20000

æ‰€ä»¥å¦‚æœå½“å‰å·²ç»è¿­ä»£äº†20000æ¬¡,å°±è‚¯å®šèƒ½åˆ°è¾¾ç»ˆç‚¹

```java
class Solution {
    static int dirs[][] = new int[][]{{0,1}, {1,0}, {-1,0}, {0,-1}};
    static int limit = (int)1e6;
    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {
        Set<String> blocks = new HashSet<>();
        for(int block[] : blocked)
            blocks.add(block[0] + ":" + block[1]);
        return bfs(source, target, blocks) && bfs(target, source, blocks);
    }
    public boolean bfs(int[] source, int[] target, Set<String> blocks){
        Set<String> seen = new HashSet<>();
        seen.add(source[0] + ":" + source[1]);
        Queue<int[]> bfs = new LinkedList<>();
        bfs.offer(source);
        
        while(!bfs.isEmpty()){
            int cur[] = bfs.poll();
            for(int dir[] : dirs){
                int nextX = cur[0] + dir[0];
                int nextY = cur[1] + dir[1];
                if(nextX < 0 || nextY < 0 || nextX >= limit || nextY >= limit) continue;
                String key = nextX + ":" + nextY;
                if(seen.contains(key) || blocks.contains(key)) continue;
                if(nextX == target[0] && nextY == target[1]) return true;
                bfs.offer(new int[]{nextX, nextY});
                seen.add(key);
            }
            // å› ä¸º blocked çš„ length æ˜¯ 200
            // å¦‚æœä½¿ç”¨è¿™ 200 ä¸ª block å¯ä»¥å›´æˆæœ€å¤§çš„åŒºåŸŸæ˜¯ 19900ï¼Œå¦‚ä¸‹ï¼š
            /*
                0th      _________________________
                        |O O O O O O O X
                        |O O O O O O X
                        |O O O O O X
                        |O O O O X
                        .O O O X
                        .O O X
                        .O X
                200th   |X
            ä»ä¸Šé¢å¯ä»¥è®¡ç®—å‡º blockï¼ˆå³ Xï¼‰å¯ä»¥å›´åŸçš„æœ€å¤§åŒºåŸŸ(æ˜¯ä¸€ä¸ªè§’çš„ä¸‰è§’å½¢)ï¼Œå¤§å°è®¡ç®—å¦‚ä¸‹ï¼š
            1 + 2 + 3 + 4 + ... + 199 = (1 + 199) * 199 / 2 = 19900
            è¿™é‡Œæˆ‘ä»¬å‘ä¸Šå–æ•´ä¸º 20000ã€‚
            */
            // ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœè¿­ä»£äº† 20000 æ­¥è¿˜èƒ½ç»§ç»­èµ°çš„è¯ï¼Œé‚£ä¹ˆæ˜¯è‚¯å®šå¯ä»¥åˆ°è¾¾ target çš„
            if(seen.size() == 20000) return true;
        }
        return false;
    }
}

```

#### [ 3.ç›¸ä¼¼åº¦ä¸º K çš„å­—ç¬¦ä¸²](https://leetcode-cn.com/problems/k-similar-strings/)

![image-20201228154119431](https://gitee.com/zisuu/picture/raw/master/img/20201228154119.png)

è¿™é¢˜å’Œå‰æ–‡å†™çš„æ™ºåŠ›æ¸¸æˆå¾ˆåƒ,éƒ½æ˜¯å¯¹å­—ç¬¦ä¸²çš„æœç´¢

> æƒ³åƒä¸€ä¸‹ï¼Œå¯¹äºbcababcï¼ˆAä¸²ï¼‰å’Œacbcbabï¼ˆBä¸²ï¼‰æ€ä¹ˆæ¥æœç´¢ï¼Œé¦–å…ˆæˆ‘ä»¬çœ‹ç¬¬1ä¸ªå­—æ¯ï¼ŒBä¸²æ˜¯aï¼ŒAä¸²æ˜¯bï¼Œæ‰€ä»¥ä½ è‚¯å®šè¦åœ¨Aä¸²ä¸­æ‰¾åˆ°1ä¸ªaå»æ¢åˆ°æœ€å¼€å§‹çš„ä½ç½®æ‰è¡Œï¼Œ
> ä½†åªæ‰¾1ä¸ªaæ˜¯ä¸è¡Œçš„, å› ä¸ºä½ ä¸ç¡®å®šç§»åŠ¨å“ªä¸ªaä¼šç¦»æœ€ç»ˆç»“æœæ›´è¿‘ï¼Œå› æ­¤éƒ½è¦è¿›è¡Œéå†ï¼Œä¹Ÿå°±æ˜¯è¦å°†acbbabcï¼ˆç¬¬1ä¸ªaå’Œæœ€å¼€å§‹çš„bäº¤æ¢ï¼‰å’Œacabbbc(ç¬¬2ä¸ªaå’Œæœ€å¼€å§‹çš„bäº¤æ¢)è¿™2ä¸ªæƒ…å†µéƒ½æ¨è¿›é˜Ÿåˆ—ã€‚
> æ¥ä¸‹æ¥æ€ä¹ˆæœï¼Ÿ å½“ä¸Šè¿°2ä¸ªå­—ç¬¦ä¸²å‡ºé˜Ÿåˆ—ä¹‹åï¼Œæˆ‘ä»¬ä¼šå‘ç°ç¬¬1ä¸ªå­—æ¯å·²ç»ä¸ç”¨åŠ¨äº†ï¼Œä½†å·§åˆçš„æ˜¯ç¬¬2ä¸ªå­—æ¯ï¼Œè¿™2ä¸ªé˜Ÿåˆ—å¼¹å‡ºçš„ä¸²å’ŒBä¸²éƒ½æ˜¯å­—æ¯cï¼Œé‚£ä¹ˆå¯ä»¥è·³è¿‡è¿™ä¸ªå­—æ¯ç»§ç»­å¾€åæ‰¾ï¼Œé‡å¤å‰é¢çš„å¤„ç†ï¼Œäºæ˜¯å¾—å‡ºç®—æ³•ã€‚
>
> ç®—æ³•ï¼š
>
> å°†Aæ¨å…¥é˜Ÿåˆ—ï¼›
> å–é˜Ÿåˆ—ä¸­å‰©ä½™çš„å…ƒç´ é•¿åº¦quelenä½œä¸ºæœ¬è½®å¾ªç¯çš„æ¬¡æ•°ï¼ˆå¹¿æœï¼‰ï¼š
> 1ï¼‰å¼¹å‡º1ä¸ªå­—ç¬¦ä¸²sï¼›
> 2ï¼‰è¿™ä¸ªå­—ç¬¦ä¸²å’ŒBä¸²æ¯”è¾ƒï¼Œæ‰¾åˆ°ç¬¬1ä¸ªä¸ç›¸åŒå­—ç¬¦çš„ä½ç½®kï¼›
> 3ï¼‰å¼¹å‡ºçš„å­—ç¬¦ä¸²ï¼Œä»è¿™ä¸ªä¸ç›¸åŒçš„ä½ç½®å¼€å§‹å¾€åæ‰¾ï¼Œæ‰¾åˆ°1ä¸ªå’ŒB[k]è¿™ä¸ªä½ç½®ç›¸åŒçš„å­—ç¬¦çš„ä½ç½®ï¼Œè®°ä¸ºjï¼›
> 4ï¼‰äº¤æ¢s[j]å’Œs[k]å¾—åˆ°æ–°ä¸²m;
> 5) å¦‚æœmä¹‹å‰ä»æœªæœç´¢è¿‡ï¼ˆå¦‚ä½•ç¡®è®¤æ˜¯å¦æœè¿‡ï¼Ÿä½¿ç”¨hashè¡¨ä¿å­˜è¿™ä¸ªä¸²ï¼Œå¦‚æœä¸‹æ¬¡èƒ½hashåˆ°ï¼Œè¯´æ˜ä¹‹å‰æœè¿‡ï¼‰ï¼Œåˆ™æ¨å…¥é˜Ÿåˆ—ï¼›
> 6ï¼‰é‡å¤æ“ä½œ3)åˆ°5)ï¼Œç›´åˆ°å†ä¹Ÿæ— æ³•æ»¡è¶³3ï¼‰è¿™ä¸ªæ¡ä»¶ï¼›
> ä¸€è½®å­—ç¬¦ä¸²æœå®Œï¼Œå±‚æ•°+1ï¼Œç„¶åçœ‹ä¸€ä¸‹é˜Ÿåˆ—ä¸­æ˜¯å¦è¿˜æœ‰å…ƒç´ ï¼Œé‡å¤æ­¥éª¤2.
> å¦‚æœåœ¨æ­¥éª¤2ä¸­åœ¨æŸæ¬¡çš„äº¤æ¢s[j]å’Œs[k]è¿‡ç¨‹ä¸­å‘ç°ä¸å­—ç¬¦ä¸²Bå®Œå…¨ç›¸åŒï¼Œåˆ™æ‰¾åˆ°ç›®æ ‡ï¼Œè¿”å›ç»“æœä¸ºå±‚æ•°+1;

```c++
class Solution {
public:
    int kSimilarity(string A, string B) {
        if(A==B)
            return 0;
        int step=0;
        queue<string> q;
        map<string,int> m;
        q.push(A);
        m[A]=1;
        while(!q.empty())
        {
            int size=q.size();
            step++;
            for(int i=0;i<size;i++)
            {
                string cur=q.front();
                q.pop();
                int index=0;
                while(cur[index]==B[index])index++;
                for(int j=index+1;j<cur.size();j++)
                {
                    if(cur[j]==B[j]||cur[j]!=B[index])continue;
                    string temp(cur);
                    turn(temp,index,j);
                    if(m[temp])continue;
                    if(temp==B)return step;
                    m[temp]=1;
                    q.push(temp);
                }

            }
        }
        return -1;
    }
    void turn(string& s,int x,int y)
    {
        char temp=s[x];
        s[x]=s[y];
        s[y]=temp;
    }
};
```

#### 4.[åˆ é™¤æ— æ•ˆçš„æ‹¬å·](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

![image-20201228163914655](https://gitee.com/zisuu/picture/raw/master/img/20201228163914.png)

è¿™é¢˜æ²¡ä»€ä¹ˆå¥½è¯´çš„..æ¨¡æ¿æ:

```c++
class Solution {
public:
    vector<string> removeInvalidParentheses(string s) {
        vector<string> result;
        map<string,int> hash;
        queue<string> q;
        q.push(s);
        hash[s]=1;
        while (!q.empty())
        {
            int size=q.size();
            //ä¸€å±‚ä¸€å±‚éå†
            while(size--)
            {
                string cur=q.front();
                q.pop();
                if(isValid(cur))
                {
                    result.push_back(cur);
                    continue;
                }
                for(int i=0;i<cur.size();i++)
                {
                    if(cur[i]=='('||cur[i]==')')
                    {
                        string temp=reduce(cur,i);
                        if(!hash[temp])
                        {
                            hash[temp]=1;
                            q.push(temp);
                        }
                    }
                }
            }
            //å› ä¸ºé¢˜ç›®è¦æ±‚æ˜¯æœ€å°åˆ é™¤æ•°,æ‰€ä»¥å¦‚æœä¸€å±‚è¿‡åå·²ç»æœ‰åˆæ³•çš„äº†,å°±ä¸ç”¨å†éå†äº†
            if(result.size())
                return result;
        }
        if(result.size()==0)
            result.push_back("");
        return result;
    }
    /**
     * åˆ é™¤indexä¸‹æ ‡
     * @param s 
     * @param index 
     * @return 
     */
    string reduce(string  s,int  index)
    {
        string temp;
        temp+=s.substr(0,index);
        temp+=s.substr(index+1,s.length());
        return temp;
    }
    /**
     * åˆ¤æ–­æ˜¯å¦æ˜¯åˆæ³•æ‹¬å·
     * @param s 
     * @return 
     */
    bool isValid(string s)
    {
        int left=0;
        for(auto k:s){
            if(k=='(')
                left++;
            else if(k==')')
            {
                left--;
                if(left<0)
                    return false;
            }
        }
        return left==0;
    }
    
};
```



### ä¸€ æ‹“æ‰‘ç±»å‹

#### [ 1.01 çŸ©é˜µ](https://leetcode-cn.com/problems/01-matrix/)







#### [2. é‡æ–°è§„åˆ’è·¯çº¿](https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/)

![image-20201227153104822](https://gitee.com/zisuu/picture/raw/master/img/20201227153104.png)

![image-20201227153112342](https://gitee.com/zisuu/picture/raw/master/img/20201227153112.png)



åŒæ ·ç”¨åˆ°å‰æ–‡è®²çš„bfsæ€æƒ³,æœ¬é¢˜çš„æ„æ€å°±æ˜¯,ä»0å¼€å§‹,å¾€ä¸‹éå†,è§‚å¯Ÿè¯¥è¾¹çš„æ–¹å‘,è‹¥æ–¹å‘ä¸æ˜¯æŒ‡å‘0,å°†é”™è¯¯æ–¹å‘è¿›è¡Œæ‰­è½¬å³å¯

å®ä¾‹1å¾ˆå¥½çš„è§£é‡Šäº†è¿™ç§æ‰­è½¬çš„è¿‡ç¨‹

```c++
class Solution {
public:
int minReorder(int n, vector<vector<int>>& connections) {
    vector<vector<int>> graph(n,vector<int>());
    //è®°å½•æ¯ä¸ªé¡¶ç‚¹æ‰€æ‹¥æœ‰çš„è¾¹çš„ç´¢å¼•
    for (int i = 0; i <connections.size() ; ++i) {
        graph[connections[i][0]].push_back(i);
        graph[connections[i][1]].push_back(i);
    }
    vector<bool> flag(n, false);
    queue<int> st;
    st.push(0);
    int ans=0;
    while(!st.empty()){
        auto top=st.front();
        st.pop();
        for(auto k:graph[top]){
            //å¦‚æœè¿™æ¡è¾¹è¿˜æ²¡è¢«è®¿é—®
            if(flag[k])continue;
            flag[k]= true;
            int start=connections[k][0];
            int end=connections[k][1];
            //å¦‚æœstart==top,è¯´æ˜è¾¹çš„æ–¹å‘é”™è¯¯,éœ€è¦æ‰­è½¬
            ans+=(start==top);
            start=(start==top?end:start);
            st.push(start);
        }
    }
    return ans;
}
};
```







## ä¸‰ è¿­ä»£åŠ æ·±æœç´¢

### 1.å¿«é€Ÿå¹‚æ¬¡æ•°

![](https://gitee.com/zisuu/picture/raw/master/img/20210104162743.png)

è¾“å…¥æ ·ä¾‹ 1 

```
1
31
70
91
473
512
811
953
0
```

è¾“å‡ºæ ·ä¾‹ 1

```
0
6
8
9
11
9
13
12
```

è¿­ä»£åŠ æ·±ç®—æ³•:

ç”±å½“å‰å±‚çš„æ•°æ¨å‡ºä¸‹ä¸€å±‚çš„çŠ¶æ€

```c++
#include<bits/stdc++.h>
using namespace std;
int n,deep;
int a[20000]={0};
int vis[20000]={0};
int limit=1000;
bool dfs(int pos){
    //å¦‚æœè¶…è¿‡äº†ç•Œé™æ·±åº¦
    if (pos > deep) return false;

    // å¦‚æœæ”¾å¤§äº†2^(deep-pos)è¿˜æ¯”nå°,åˆ™ç›´æ¥è¿”å›false
    if(((a[pos]<<(deep-pos)))<n) return false;

    //æ‰¾åˆ°äº†,ç›´æ¥è¿”å›true
    if (a[pos] == n) return true;

    //æšä¸¾çŠ¶æ€
    for (int i=1;i<=pos;i++)
    {
        //ç›¸ä¹˜
        int t=  a[pos]+a[i];

        //é¢˜ç›®è¯´æ˜næœ€å¤§å€¼ä¸è¶…è¿‡1000
        if ( t>0&&t<limit&&!vis[t] )
        {
            a[pos+1]= t;
            if ( dfs(pos+1) ) return true;
            vis[t]=0;
        }

        //ç›¸é™¤
        t=  a[pos]-a[i];
        if (t>0&&t<limit&&!vis[t])
        {
            a[pos+1]= t;
            if ( dfs(pos+1) ) return true;
            vis[t]=0;
        }
    }
    return false;
}
int main()
{
    a[1]=1;
    while( cin>>n&& n ){
        deep=0;
        while (true) {
            if (dfs(1)) {
                cout<<deep-1;
                break;
            }
            deep++;
        }
    }
}
```



### 2.å››å­è¿æ£‹

åœ¨ä¸€ä¸ª4*4çš„æ£‹ç›˜ä¸Šæ‘†æ”¾äº†14é¢—æ£‹å­ï¼Œå…¶ä¸­æœ‰7é¢—ç™½è‰²æ£‹å­ï¼Œ7é¢—é»‘è‰²æ£‹å­ï¼Œæœ‰ä¸¤ä¸ªç©ºç™½åœ°å¸¦ï¼Œä»»ä½•ä¸€é¢—é»‘ç™½æ£‹å­éƒ½å¯ä»¥å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ç§»åŠ¨åˆ°**ç›¸é‚»çš„ç©ºæ ¼**ï¼Œè¿™å«è¡Œæ£‹ä¸€æ­¥ï¼Œé»‘ç™½åŒæ–¹äº¤æ›¿èµ°æ£‹ï¼Œä»»æ„ä¸€æ–¹å¯ä»¥å…ˆèµ°ï¼Œå¦‚æœæŸä¸ªæ—¶åˆ»ä½¿å¾—ä»»æ„ä¸€ç§é¢œè‰²çš„æ£‹å­å½¢æˆå››ä¸ªä¸€çº¿ï¼ˆåŒ…æ‹¬æ–œçº¿ï¼‰ï¼Œè¿™æ ·çš„çŠ¶æ€ä¸ºç›®æ ‡æ£‹å±€ã€‚

â— â—‹ â—

â—‹ â— â—‹ â—

â— â—‹ â— â—‹

â—‹ â— â—‹

**è¾“å…¥æ ¼å¼ï¼š**

ä»æ–‡ä»¶ä¸­è¯»å…¥ä¸€ä¸ª4*4çš„åˆå§‹æ£‹å±€ï¼Œé»‘æ£‹å­ç”¨Bè¡¨ç¤ºï¼Œç™½æ£‹å­ç”¨Wè¡¨ç¤ºï¼Œç©ºæ ¼åœ°å¸¦ç”¨Oè¡¨ç¤º

**è¾“å‡ºæ ¼å¼ï¼š**

ç”¨æœ€å°‘çš„æ­¥æ•°ç§»åŠ¨åˆ°ç›®æ ‡æ£‹å±€çš„æ­¥æ•°ã€‚

**è¾“å…¥æ ·ä¾‹#1ï¼š**

```
BWBO
WBWB
BWBW
WBWO
```

**è¾“å‡ºæ ·ä¾‹#1ï¼š**

```
5
```

### 

```c++
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;
 
int board[5][5];//æ£‹ç›˜å®šä¹‰
 
int movex[5] = { 0,-1,0,1,0 },
movey[5] = { 0,0,1,0,-1 };//ç§»åŠ¨åæ ‡  ä¸åŠ¨  å·¦ ä¸Š å³ ä¸‹
 
int o_x1, o_y1, //ç¬¬ä¸€ä¸ªç©ºæ ¼åæ ‡
o_x2, o_y2, //ç¬¬äºŒä¸ªç©ºæ ¼åæ ‡
max_level, //dfsæœç´¢æœ€å¤§å±‚æ•°
f; //ç»“æœæ ‡å¿—
 
int can_move(int a, int b, int k) {
	//å¦‚æœç§»åŠ¨åçš„ç©ºæ ¼çš„åæ ‡çš„é¢œè‰²å’Œæ“ä½œäººçš„é¢œè‰²ä¸åŒå¹¶ä¸”æ­¤æ¬¡ç§»åŠ¨è¯¥ç©ºæ ¼è¿˜åœ¨æ£‹ç›˜å†… åˆ™æ­¤æ¬¡æ“ä½œå¯ä»¥è¿›è¡Œå¦åˆ™ä¸èƒ½è¿›è¡Œ (ä¾‹å¦‚æŒé»‘è‰²æ£‹å­å…ˆç§»åŠ¨åˆ™ä»–åº”è¯¥ç§»åŠ¨ç™½å­)
	if (board[a][b] != k && a >= 1 && a <= 4 && b >= 1 && b <= 4) return 1;
	else return 0;
}
int is_win() {
	
	for (int i = 1; i <= 4; i++) {
		//è¡Œ
		if (board[i][1] == board[i][2] && board[i][2] == board[i][3] && board[i][3] == board[i][4]) return 1;
		//åˆ—
		if (board[1][i] == board[2][i] && board[2][i] == board[3][i] && board[3][i] == board[4][i]) return 1;
	}
	//å¯¹è§’çº¿
	if (board[1][1] == board[2][2] && board[2][2] == board[3][3] && board[3][3] == board[4][4]) return 1;
	if (board[1][4] == board[2][3] && board[2][3] == board[3][2] && board[3][2] == board[4][1]) return 1;
	return 0;
}
void dfs(int x1, int y1, int x2, int y2, int pre, int level) {
	if (is_win()) {
		f = 1;
		return;
	}
	else if (level > max_level) return;
	for (int i = 1; i <= 4; i++) {
		int nx = x1 + movex[i];
		int ny = y1 + movey[i];
		int np = x2 + movex[i];
		int nq = y2 + movey[i];
		//ç§»åŠ¨ç¬¬ä¸€ä¸ªç©ºæ ¼
		if (can_move(nx, ny, pre)) {
			//äº¤æ¢ç©ºæ ¼å’Œè¦æ›¿æ¢çš„ä½ç½®
			swap(board[x1][y1], board[nx][ny]);
			//å¯¹æ‰‹å†è¿›è¡Œç§»åŠ¨ 
			dfs(nx, ny, x2, y2, board[x1][y1], level + 1);
			//ç§»åŠ¨ç»“æŸæ¢å¤åŸæ¥çš„ä½ç½® å¦‚æœ f ä¸ä¸º0 è¯´æ˜æ‰¾åˆ°ç»“æœ
			swap(board[x1][y1], board[nx][ny]);
		}
		//ç§»åŠ¨ç¬¬äºŒä¸ªç©ºæ ¼
		if (can_move(np, nq, pre)) {
			//äº¤æ¢ç©ºæ ¼å’Œè¦æ›¿æ¢çš„ä½ç½®
			swap(board[x2][y2], board[np][nq]);
			//å¯¹æ‰‹å†è¿›è¡Œç§»åŠ¨ 
			dfs(x1, y1, np, nq, board[x2][y2], level + 1);
			//ç§»åŠ¨ç»“æŸæ¢å¤åŸæ¥çš„ä½ç½® å¦‚æœ f ä¸ä¸º0 è¯´æ˜æ‰¾åˆ°ç»“æœ
			swap(board[x2][y2], board[np][nq]);
		}
	}
}
int main() {
	//æ•°æ®å‡†å¤‡æ„é€ æ£‹ç›˜æ ¼  1 ä»£è¡¨ é»‘ 2 ä»£è¡¨ç™½ 3ä»£è¡¨ç©º
	for (int i = 1; i <= 4; i++) {
		for (int j = 1; j <= 4; j++) {
			char ch;
			cin >> ch;
			if (ch == 'B') board[i][j] = 1;
			else if (ch == 'W') board[i][j] = 2;
			else {
				board[i][j] = 3;
				if (!o_x1) {
					o_x1 = i, o_y1 = j;
				}
				else {
					o_x2 = i, o_y2 = j;
				}
			}
		}
	}
	//é‡‡ç”¨è¿­ä»£åŠ æ·±æœç´¢ç®—æ³•è®¡ç®—
	for (max_level = 0;; max_level++) {
		dfs(o_x1,o_y1,o_x2,o_y2, 1, 1);//é»‘è‰²å…ˆæ‰‹ 1
		dfs(o_x1,o_y1,o_x2,o_y2, 2, 1);//ç™½è‰²å…ˆæ‰‹ 2
		//fä¸ä¸º0è¯´æ˜æ‰¾åˆ°ç§»åŠ¨æ¬¡æ•°
		if (f) {
			printf("%d", max_level);
			return 0;
		}
	}
	return 0;
}
```

### 3.[æ»‘åŠ¨è°œé¢˜](https://leetcode-cn.com/problems/sliding-puzzle/)

![image-20210104183004500](https://gitee.com/zisuu/picture/raw/master/img/20210104183024.png)

å’Œä¸Šä¸€é¢˜å·®ä¸å¤š

```c++
#include <bits/stdc++.h>
using namespace std;
int directions [4][2]={1,0,0,1,-1,0,0,-1};
vector<vector<int>> graph;
int deep;
bool isEqual ()
{
    return graph[0][0] == 1
           && graph[0][1] == 2 && graph[0][2] == 3
           && graph[1][0] == 4 && graph[1][1] == 5
           && graph[1][2] == 0;
}
bool isOk(int x,int y)
{
    return x>=0&&x<2&&y>=0&&y<3;
}
bool dfs (int x,int y,int level)
{
    if (level>deep) return false;
    if (isEqual()) return true;
    for (auto direct:directions)
    {
        int nx= x+direct[0];
        int ny= y+direct[1];
        if (isOk(nx,ny))
        {
            swap(graph[x][y],graph[nx][ny]);
            if (dfs(nx,ny,level+1)) return true;
            swap(graph[x][y],graph[nx][ny]);
        }
    }
    return false;
}
int slidingPuzzle(vector<vector<int>>& board) {
    graph=board;
    deep=0;
    int nx=0,ny=0;
    for(int i=0;i<2;i++)
    {
        for(int j=0;j<3;j++)
        {
            if(!graph[i][j])
            {
                nx=i,ny=j;
                break;
            }
        }
    }
    for(;deep<=26;deep++){
        if (dfs(nx,ny,1))
        {
           return deep-1;
        }
    }
    return -1;
}
```

### 4.è´ªåƒè›‡

![image-20210104210848293](https://gitee.com/zisuu/picture/raw/master/img/20210104210848.png)

**è¾“å…¥**

è¾“å…¥åŒ…å«å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„ç¬¬ä¸€è¡ŒåŒ…å«3ä¸ªæ•´æ•°n,m,Lã€‚è¡¨ç¤ºåœ°å›¾å…±æœ‰nè¡Œmåˆ—(1<=m,n<=20).è›‡çš„èº«å­å…±æœ‰Læ®µã€‚æ¥ä¸‹æ¥Lè¡Œæ˜¯è›‡çš„Læ®µèº«å­çš„åæ ‡ï¼ˆè¿™Læ®µèº«å­æ€»æ˜¯ç›¸é‚»çš„ï¼Œé¦–å…ˆè¾“å…¥çš„æ˜¯è›‡å¤´åæ ‡ï¼‰ã€‚æ¥ä¸‹æ¥ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°Kï¼Œè¡¨æ˜éšœç¢ç‰©å ç”¨çš„æ ¼å­æ•°ï¼Œæ¥ä¸‹æ¥Kè¡Œæ˜¯Kä¸ªéšœç¢ç‰©çš„åæ ‡ã€‚æ¥ä¸‹æ¥æ˜¯ä¸€ä¸ªç©ºè¡Œåˆ†éš”ä¸åŒçš„æµ‹è¯•ç”¨ä¾‹ã€‚å½“æµ‹è¯•ç”¨ä¾‹ç¬¬ä¸€è¡Œæ˜¯3ä¸ª0ï¼Œè¡¨æ˜è¾“å…¥ç»“æŸã€‚

**è¾“å‡º**

å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œè¾“å‡ºä¸€è¡ŒåŒ…å«æµ‹è¯•ç”¨ä¾‹å·ï¼Œæ¥ç€æ˜¯è›‡å¤´åˆ°è¾¾å·¦ä¸Šè§’åæ ‡ä¸º(1,1)æ ¼å­çš„æœ€å°‘æ­¥æ•°ï¼Œ-1è¡¨ç¤ºæ— è§£ã€‚



**è¾“å…¥æ ·ä¾‹ 1** 

```
5 6 4
4 1
4 2
3 2
3 1
3
2 3
3 3
3 4

4 4 4
2 3
1 3
1 4
2 4
4
2 1
2 2
3 4
4 2

0 0 0
```

**è¾“å‡ºæ ·ä¾‹ 1**

```
Case 1: 9
Case 2: -1
```



éœ€è¦ç”¨åŒç«¯é˜Ÿåˆ—æ¥ä¿å­˜è›‡çš„èº«ä½“

è›‡å¤´ç§»åŠ¨å®é™…å°±æ˜¯å»é™¤è›‡å°¾+åŠ å…¥ä¸‹ä¸€ä¸ªè›‡å¤´

```c++
#include <bits/stdc++.h>
using namespace std;
int directions [4][2]={1,0,0,1,-1,0,0,-1};
typedef pair<int,int> ll;
//å­˜å‚¨ğŸçš„èº«ä½“
deque<ll> snack;
//å­˜å‚¨ç½‘æ ¼,1ä»£è¡¨éšœç¢ç‰©,2ä»£è¡¨ğŸçš„èº«ä½“
int graph [25][25]={0};
int vis[25][25]={0};
int m,n,k;
int deep;
bool flag;
bool isOk(int x,int y)
{
    return x>=1&&x<=m&&y>=1&&y<=n&&graph[x][y]!=1&&graph[x][y]!=2&&!vis[x][y];
}
/**
 * x,yä»£è¡¨å½“å‰ğŸçš„å¤´éƒ¨åæ ‡
 * @param x
 * @param y
 * @param level
 * @return
 */
bool dfs(int x,int y,int level)
{
    if (level>deep)return false;
    if (x==1&&y==1)return true;
    for(auto direct:directions)
    {
        int nx= x+direct[0];
        int ny= y+direct[1];
        if (isOk(nx,ny))
        {
           
            ll back=snack.back();snack.pop_back();
            graph[back.first][back.second]=0;
            graph[nx][ny]=2;
            snack.push_front({nx,ny});
            vis[nx][ny]=1;
            if(dfs(nx,ny,level+1))
                return true;
            snack.pop_front();
            snack.push_back(back);
            graph[nx][ny]=0;
            graph[back.first][back.second]=2;
            vis[nx][ny]=0;
        }
    }
    return false;
}
int main()
{
    int num=0;
    while(cin>>m>>n>>k&&m&&n&&k)
    {
        int a,b;
        int topx=0,topy=0;
        flag=false;
        deep=0;
        snack.clear();
        memset(graph,0,sizeof(graph));
        memset(vis,0,sizeof(vis));
        for(int i=0;i<k;i++)
        {
            cin>>a>>b;
            if(!topx)topx=a,topy=b;
            snack.push_back({a,b});
            graph[a][b]=2;
        }
        int block;
        cin>>block;
        for(int i=0;i<block;i++)
        {
            cin>>a>>b;
            graph[a][b]=1;
        }
        for(int i=0;i<=m*n;i++)
        {
            deep++;
            if (dfs(topx,topy,1))
            {
                flag=true;
                break;
            }
        }
        if(flag)
        {
            cout<<"Case "<<++num<<": "<<deep-1<<endl;
        }else{
            cout<<"Case "<<++num<<": "<<-1<<endl;
        }
    }
}
```



## å›› è¿­ä»£åŠ æ·±æœç´¢ä¸ä¼°ä»·å‡½æ•°

### 1.åŸƒåŠåˆ†æ•°

é‚£ä¹ˆä»€ä¹ˆæ˜¯ä¹è§‚ä¼°ä»·å‡½æ•°å‘¢ï¼Ÿç®€å•çš„è¯´å°±æ˜¯ä»å½“å‰æ·±åº¦åˆ°æ‰¾åˆ°æœ€ç»ˆçš„è§£â€œè‡³å°‘â€è¿˜éœ€è¦å¤šå°‘æ­¥ï¼Œæˆ–è€…è·ç¦»æ‰¾åˆ°æœ€ç»ˆçš„è§£è¿˜éœ€è¦æ‰©å±•å¤šå°‘å±‚ã€‚å¦‚æœè¶…å‡ºäº†å½“å‰é™åˆ¶çš„æ·±åº¦maxdï¼Œè¯´æ˜å½“å‰é™åˆ¶çš„æœ€å¤§æ·±åº¦ä¸‹æ˜¯ä¸å¯èƒ½æ‰¾åˆ°è§£çš„ï¼Œç›´æ¥é€€å‡ºã€‚æ¯”å¦‚â€œåŸƒåŠåˆ†æ•°â€é—®é¢˜ï¼Œè¦æ‹†åˆ†19/45è¿™æ ·çš„ä¸€ä¸ªåˆ†æ•°ï¼Œå‡è®¾å½“å‰æœç´¢åˆ°äº†ç¬¬ä¸‰å±‚ï¼Œå¾—åˆ°19/45=1/5+1/100...é‚£ä¹ˆæ ¹æ®é¢˜æ„æ­¤æ—¶æœ€å¤§çš„åˆ†æ•°ä¸º1/101ï¼Œè€Œä¸”å¦‚æœéœ€è¦å‡‘å¤Ÿ19/45ï¼Œéœ€è¦(19/45-1/5-1/100)*101=23ä¸ª1/101æ‰è¡Œã€‚å³ä»ç¬¬3å±‚è¿˜è¦å‘ä¸‹æ‰©å±•è‡³å°‘å¤§äº23å±‚çš„æ·±åº¦æ‰å¯èƒ½æ‰¾åˆ°æ‰€æœ‰çš„è§£ã€‚æ‰€ä»¥å¦‚æœæ­¤æ—¶çš„maxd<23ï¼Œå°±å¯ä»¥ç›´æ¥å‰ªæäº†ã€‚å› æ­¤(a/b-c/d)/(1/e)ä¾¿æ˜¯æœ¬é¢˜çš„ä¹è§‚ä¼°ä»·å‡½æ•°ã€‚

**é¢˜æ„ï¼š**ç»™ä½ ä¸ªçœŸåˆ†æ•°ï¼Œä½ éœ€è¦å°†å…¶åŒ–ç®€ä¸ºæœ€å°‘çš„è‹¥å¹²ç‰¹æ®ŠçœŸåˆ†æ•°ä¹‹å’Œï¼Œä½ è¦è¾“å‡ºè¿™ä¸ªåºåˆ—ï¼ˆåºåˆ—æŒ‰é€’å¢åºï¼‰ã€‚å¦‚æœæœ‰ä¸åŒçš„æ–¹æ¡ˆï¼Œåˆ™åˆ†æ•°ä¸ªæ•°ç›¸åŒçš„æƒ…å†µä¸‹ä½¿æœ€å¤§çš„åˆ†æ¯æœ€å°ã€‚è‹¥è¿˜ç›¸åŒï¼Œåˆ™ä½¿æ¬¡å¤§çš„åˆ†æ¯æœ€å¤§â€¦â€¦ä»¥æ­¤ç±»æ¨ã€‚å¦‚ï¼š2/3=1/2+1/6ï¼Œä½†ä¸å…è®¸2/3=1/3+1/3ï¼Œå› ä¸ºåŠ æ•°ä¸­æœ‰ç›¸åŒçš„ã€‚å¯¹äºä¸€ä¸ªåˆ†æ•°a/bï¼Œè¡¨ç¤ºæ–¹æ³•æœ‰å¾ˆå¤šç§ï¼Œä½†æ˜¯å“ªç§æœ€å¥½å‘¢ï¼Ÿ é¦–å…ˆï¼ŒåŠ æ•°å°‘çš„æ¯”åŠ æ•°å¤šçš„å¥½ï¼Œå…¶æ¬¡ï¼ŒåŠ æ•°ä¸ªæ•°ç›¸åŒçš„ï¼Œæœ€å°çš„åˆ†æ•°è¶Šå¤§è¶Šå¥½ã€‚

è¿™é“é¢˜ä¸åŒäºå…¶ä»–æœç´¢çš„çš„ä¸»è¦æ˜¯å®ƒçš„æœç´¢æ²¡æœ‰æ˜æ˜¾çš„ä¸Šç•Œå’Œä¸‹ç•Œï¼Œæ— æ³•ç›´æ¥ä½¿ç”¨BFSå’ŒDFSï¼Œä¾‹å¦‚è¿™é“é¢˜ä¸­è®¾a/b=1/x1+1/x2+1/x3+.......1/xnå¯¹äºç”Ÿæˆçš„è§£ç­”æ•°æ ¹æœ¬æ— æ³•çŸ¥é“å®ƒçš„æ·±åº¦ï¼ˆå³nå€¼ï¼‰å’Œå®½åº¦ï¼ˆå¯¹äºæ­¤é¢˜ä¸ºï¼ˆ1ï¼Œ+âˆï¼‰ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬é€‰æ‹©ç”¨è¿­ä»£åŠ æ·±æœï¼›

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cassert>
using namespace std;
int a, b, maxd;
 
long long gcd(long long a, long long b) {
  return b == 0 ? a : gcd(b, a%b);
}
// è¿”å›æ»¡è¶³1/c <= a/bçš„æœ€å°c
inline int get_first(long long a, long long b) {
  return b/a+1;
}
const int maxn = 100 + 5;
long long v[maxn], ans[maxn];
// å¦‚æœå½“å‰è§£væ¯”ç›®å‰æœ€ä¼˜è§£ansæ›´ä¼˜ï¼Œæ›´æ–°ans
 
bool better(int d) {
  for(int i = d; i >= 0; i--) if(v[i] != ans[i]) {
    return ans[i] == -1 || v[i] < ans[i];
  }
  return false;
}
// å½“å‰æ·±åº¦ä¸ºdï¼Œåˆ†æ¯ä¸èƒ½å°äºfromï¼Œåˆ†æ•°ä¹‹å’Œæ°å¥½ä¸ºaa/bb
bool dfs(int d, int from, long long aa, long long bb) {
  if(d == maxd) {
    if(bb % aa) return false; // aa/bbå¿…é¡»æ˜¯åŸƒåŠåˆ†æ•°
    v[d] = bb/aa;
    if(better(d)) memcpy(ans, v, sizeof(long long) * (d+1));
    return true;
  }
  bool ok = false;
  from = max(from, get_first(aa, bb)); // æšä¸¾çš„èµ·ç‚¹
  for(int i = from; ; i++) {
    // å‰ªæï¼šå¦‚æœå‰©ä¸‹çš„maxd+1-dä¸ªåˆ†æ•°å…¨éƒ¨éƒ½æ˜¯1/iï¼ŒåŠ èµ·æ¥ä»ç„¶ä¸è¶…è¿‡aa/bbï¼Œåˆ™æ— è§£
    if(bb * (maxd+1-d) <= i * aa) break;
    v[d] = i;
    // è®¡ç®—aa/bb - 1/iï¼Œè®¾ç»“æœä¸ºa2/b2
    long long b2 = bb*i;
    long long a2 = aa*i - bb;
    long long g = gcd(a2, b2); // ä»¥ä¾¿çº¦åˆ†
    if(dfs(d+1, i+1, a2/g, b2/g)) ok = true;
  }
  return ok;
}
int main() {
  int kase = 0;
  while(cin >> a >> b) {
    int ok = 0;
    for(maxd = 1; maxd <= 100; maxd++) {
      memset(ans, -1, sizeof(ans));
      if(dfs(0, get_first(a, b), a, b)) { ok = 1; break; }
    }
    cout << "Case " << ++kase << ": ";
    if(ok) {
      cout << a << "/" << b << "=";
      for(int i = 0; i < maxd; i++) cout << "1/" << ans[i] << "+";
      cout << "1/" << ans[maxd] << "\n";
    } else cout << "No solution.\n";
  }
  return 0;
}
```



