# 0 思维导图

![image-20201123162652292](https://gitee.com/zisuu/picture/raw/master/img/20201123162653.png)

# 一 进程与线程

### 1.1 进程的定义

为了方便操作系统管理,完成各程序并发执行,引入了进程等相关概念

程序段,数据段,PCB三部分构成了进程实体,一般情况下,我们把进程实体称为进程

PCB是进程存在的唯一标识.因此,所谓创建进程就是创建进程中的PCB,撤销进程就是

撤销进程中的PCB

引入进程实体的概念后,进程可定义未:

> 进程是进程实体的运行过程,是系统进行资源分配和调度的基本单位

### 1.2 进程的组成与组织

#### (一) 组成

进程是由程序段,数据段和PCB三部分组成

- 而其中最重要的就是`进程控制块PCB`（Process Control Block）
- PCB简介：
          PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。
          PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。
          或者说，`OS是根据PCB来对并发执行的进程进行控制和管理的。`
          例如，当OS要`调度`某进程执行时，要从该进程的PCB中查处其现行状态及优先级；在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；
          进程在`执行`过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问PCB；
          当进程由于某种原因而`暂停`执行时，又须将断点的处理机环境保存在PCB中。
          可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。
          所以说，PCB是进程存在的唯一标志。

PCB通常包含的内容：
![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213444.png)



#### (二) 组织

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213449.png)

#### （1）链接方式

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213456.png)

#### （2）索引方式

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213458.png)



### 1.3 进程的特征

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213502.png)



### 1.4 进程的状态与转化

#### (一) 进程状态

- 运行态:已占有CPU处理机,并正在运行
- 就绪态: 以具备运行的条件(即获取了除了CPU外的一切资源),但因为还未获取CPU而在就绪队列上等待
- 阻塞态:因为等待某一件事件而让出了CPU,暂停运行.如等待操作系统分配打印机,等待磁盘读写操作等
- 创建态:进程正在被创建.进程创建需要许多步骤:
  - 首先创建一个PCB
  - 向PCB中填写一些控制和管理进程的信息
  - 系统为进程分配运行时所必须的资源
- 结束态:进程运行结束.操作系统回收相关资源

#### (二) 状态转化

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213507.png)

### 1.5 原语实现进程控制

#### (一) 进程控制及原语

> 进程控制的主要功能是对系统中的所有进程施行有效的管理,主要具有:
>
> - 创建进程
> - 删除进程
> - 切换进程状态等

在操作系统中,将进程控制所用到的程序段成为原语,原语的特点就是执行期间不中断,只能一气呵成

原语采用关中断和开中断的指令实现:

![60519394897](https://gitee.com/zisuu/picture/raw/master/img/20201121213510.png)

#### (二) 五种进程控制原语

- 进程创建原语

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213512.png)

- 进程终止

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213514.png)

- 进程唤醒和阻塞

> 这是一对成双出现的原语,阻塞就必须伴随着唤醒
>
> 阻塞原语 是进程进行了系统调用
>
> 唤醒原语是 系统调用等相关操作结束后唤醒被阻塞的线程

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213517.png)

- 进程切换

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213518.png)

#### (三) 进程控制总结

- 进程控制,只是变化PCB的位置,程序本身还是在内存中的这也体现了,os是根据PCB来对进程进行管理和调度的

- 进程控制相同点:

  ![60519454152](D:\Typora\java核心\计算机九阳神功\操作系统\assets\1605194541527.png)

### 1.6 进程通信

首先,进程是系统资源分配的基本单位,每个进程都有自己独立的内存空间,与其他进程相互隔离

为了保护进程安全,进程不能直接访问另一个进程的内存空间

但是,各个进程间数据的交互又是必须的

因此,操作系统提供了三种让进程通信的方式:

![60519471415](https://gitee.com/zisuu/picture/raw/master/img/20201121213522.png)

#### (一) 共享存储

> 共享一块到家都能访问的空间,但为互斥共享,进每次只能有一个线程进行读写操作

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213525.png)

#### (二) 消息传递

在消息传递系统中,进程的数据交换是以格式化的数据为单位的.

- 直接通信方式:A进程直接发送消息到B进程的消息缓冲队列上
- 间接通信方式:A进程将消息发送到某个中间件上(如消息队列),B再从该中间件上取消息

#### (三)管道通信

管道通信相当于开辟了一个内存缓冲区,以实现读写进程的连接和通信,类似于java nio

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213528.png)



### 1.7 线程与多线程模型

#### (一) 线程的概念

为什么要引入线程的概念呢?

因为有的进程可能需要同时做很多事情(很多程序),如QQ(一个大进程),需要同时处理视频,聊天,传输文件等

而传统的进程只能串行的执行一系列的程序,所以为了提高系统的并发度,引入了线程的概念

![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213531.png)

#### (二) 引入线程的变化与好处

- 资源分配和调度:

  > 传统进程是资源分配和调度的基本单位
  >
  > 引入线程后,进程只作为资源分配的独立单位,而线程才是CPU调度的基本单位

- 并发性

  > 原先只能实现进程的并发
  >
  > 引入线程后,实现了进程间的线程的并发执行,提供了并发成都

- 系统开销

  > 传统的进程间并发,需要切换进程的运行环境,系统开销大,浪费了大量时间用户进程切换
  >
  > 引入线程后,同一进程内的线程可并发执行,而不需要切换进程环,大大减小系统开销

  

#### (三) 线程类型

- 用户级线程

   有关线程的管理由用户完成,内核感知不到线程的存在.

  ![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213535.png)

- 内核级线程

  线程的管理由内核完成

  ![在这里插入图片描述](https://gitee.com/zisuu/picture/raw/master/img/20201121213538.png)



#### (四) 多线程模型

> 用户级和内核级线程的交叉组合,会产生不一样的模型

- 多对一模型

![60519642998](https://gitee.com/zisuu/picture/raw/master/img/20201121213541.png)

- 一对一模型

也即每个用户级线程对应一个内核级线程,

> - 优点:并发度高,一个线程的阻塞不会导致别的线程阻塞
> -  缺点:每个线程创建一个内核线程与之对应,开销过大

![60519667296](https://gitee.com/zisuu/picture/raw/master/img/20201121213544.png)

- 多对多模型

> 多对多模型是对以上两种模型的这种,有n各用户级线程和m各内核级线程,要求(m<=n)
>
> 即解决了多对一模型并发度不高的缺点,又解决了一对一模型开销大的缺点:

![60519674075](https://gitee.com/zisuu/picture/raw/master/img/20201121213546.png)











