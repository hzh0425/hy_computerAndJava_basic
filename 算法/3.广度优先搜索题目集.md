## 一 暴力bfs搜索类型

#### [1. 公交路线](https://leetcode-cn.com/problems/bus-routes/)

![image-20201227194627772](https://gitee.com/zisuu/picture/raw/master/img/20201227194627.png)

利用bfs思路:

![image-20201227194915831](https://gitee.com/zisuu/picture/raw/master/img/20201227194915.png)

也即从start开始,一层一层往外遍历一遍,

相当于每个站点,只要它在一个路线内,就可以遍历路线内的所有站点,

如,1在路线route[0]内,它可以遍历2和7

同理,当到7时,自然而然可以遍历3和6

所以,我们需要知道每个站点在哪些个路线内,这样才能遍历路线内的每个站点

另外,我们要将路线的下标压入队列,而不是站点压入队列,

也即我们每次从队列中取出元素后,要遍历的是一整个路线中的所有站点的所有所属路线

```c++
class Solution{
public:
    int numBusesToDestination(vector<vector<int>>& routes, int S, int T) {
        if (S == T) return 0;
        int N = routes.size();
        map<int, set<int> > m; // 存储车站能通到哪些路线
        for (int i = 0; i < N; ++i) {
            for (auto j : routes[i]) {
                m[j].insert(i);
            }
        }
        vector<bool> visited(N, false); // 哪些路线被遍历过了
        queue<int> q; // 存储已经遍历过的路线
        for (auto x : m[S]) {
            q.push(x);
            visited[x] = true;
        }
        int step = 0;
        while (!q.empty()) {
            ++step;
            int s = q.size();
            for (int i = 0; i < s; ++i) {
                int t = q.front();
                q.pop();
                for (auto j : routes[t]) {
                    if (j == T) return step;
                    for (auto x : m[j]) {
                        if (!visited[x]) {
                            q.push(x);
                            visited[x] = true;
                        }
                    }
                }
            }
        }
        return -1;
    }
};

```

#### 2.[ 逃离大迷宫](https://leetcode-cn.com/problems/escape-a-large-maze/)

![image-20201228150457119](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20201228150457119.png)

![image-20201228150736281](https://gitee.com/zisuu/picture/raw/master/img/20201228150736.png)



1.这题虽然看起来就是标准的bfs模板,但如果用数组来保存已经访问过的,发现x,y=1e6

开数组会爆栈

解决方法:字符串压缩

也即把x,y变为 x:y 这种字符串放入set中

2.另外,这题还可以进行优化

因为block大小不超过200,最大能围的范围是:

1+2+...+200 ~=20000

所以如果当前已经迭代了20000次,就肯定能到达终点

```java
class Solution {
    static int dirs[][] = new int[][]{{0,1}, {1,0}, {-1,0}, {0,-1}};
    static int limit = (int)1e6;
    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {
        Set<String> blocks = new HashSet<>();
        for(int block[] : blocked)
            blocks.add(block[0] + ":" + block[1]);
        return bfs(source, target, blocks) && bfs(target, source, blocks);
    }
    public boolean bfs(int[] source, int[] target, Set<String> blocks){
        Set<String> seen = new HashSet<>();
        seen.add(source[0] + ":" + source[1]);
        Queue<int[]> bfs = new LinkedList<>();
        bfs.offer(source);
        
        while(!bfs.isEmpty()){
            int cur[] = bfs.poll();
            for(int dir[] : dirs){
                int nextX = cur[0] + dir[0];
                int nextY = cur[1] + dir[1];
                if(nextX < 0 || nextY < 0 || nextX >= limit || nextY >= limit) continue;
                String key = nextX + ":" + nextY;
                if(seen.contains(key) || blocks.contains(key)) continue;
                if(nextX == target[0] && nextY == target[1]) return true;
                bfs.offer(new int[]{nextX, nextY});
                seen.add(key);
            }
            // 因为 blocked 的 length 是 200
            // 如果使用这 200 个 block 可以围成最大的区域是 19900，如下：
            /*
                0th      _________________________
                        |O O O O O O O X
                        |O O O O O O X
                        |O O O O O X
                        |O O O O X
                        .O O O X
                        .O O X
                        .O X
                200th   |X
            从上面可以计算出 block（即 X）可以围城的最大区域(是一个角的三角形)，大小计算如下：
            1 + 2 + 3 + 4 + ... + 199 = (1 + 199) * 199 / 2 = 19900
            这里我们向上取整为 20000。
            */
            // 也就是说，如果迭代了 20000 步还能继续走的话，那么是肯定可以到达 target 的
            if(seen.size() == 20000) return true;
        }
        return false;
    }
}

```

#### [ 3.相似度为 K 的字符串](https://leetcode-cn.com/problems/k-similar-strings/)

![image-20201228154119431](https://gitee.com/zisuu/picture/raw/master/img/20201228154119.png)

这题和前文写的智力游戏很像,都是对字符串的搜索

> 想像一下，对于bcababc（A串）和acbcbab（B串）怎么来搜索，首先我们看第1个字母，B串是a，A串是b，所以你肯定要在A串中找到1个a去换到最开始的位置才行，
> 但只找1个a是不行的, 因为你不确定移动哪个a会离最终结果更近，因此都要进行遍历，也就是要将acbbabc（第1个a和最开始的b交换）和acabbbc(第2个a和最开始的b交换)这2个情况都推进队列。
> 接下来怎么搜？ 当上述2个字符串出队列之后，我们会发现第1个字母已经不用动了，但巧合的是第2个字母，这2个队列弹出的串和B串都是字母c，那么可以跳过这个字母继续往后找，重复前面的处理，于是得出算法。
>
> 算法：
>
> 将A推入队列；
> 取队列中剩余的元素长度quelen作为本轮循环的次数（广搜）：
> 1）弹出1个字符串s；
> 2）这个字符串和B串比较，找到第1个不相同字符的位置k；
> 3）弹出的字符串，从这个不相同的位置开始往后找，找到1个和B[k]这个位置相同的字符的位置，记为j；
> 4）交换s[j]和s[k]得到新串m;
> 5) 如果m之前从未搜索过（如何确认是否搜过？使用hash表保存这个串，如果下次能hash到，说明之前搜过），则推入队列；
> 6）重复操作3)到5)，直到再也无法满足3）这个条件；
> 一轮字符串搜完，层数+1，然后看一下队列中是否还有元素，重复步骤2.
> 如果在步骤2中在某次的交换s[j]和s[k]过程中发现与字符串B完全相同，则找到目标，返回结果为层数+1;

```c++
class Solution {
public:
    int kSimilarity(string A, string B) {
        if(A==B)
            return 0;
        int step=0;
        queue<string> q;
        map<string,int> m;
        q.push(A);
        m[A]=1;
        while(!q.empty())
        {
            int size=q.size();
            step++;
            for(int i=0;i<size;i++)
            {
                string cur=q.front();
                q.pop();
                int index=0;
                while(cur[index]==B[index])index++;
                for(int j=index+1;j<cur.size();j++)
                {
                    if(cur[j]==B[j]||cur[j]!=B[index])continue;
                    string temp(cur);
                    turn(temp,index,j);
                    if(m[temp])continue;
                    if(temp==B)return step;
                    m[temp]=1;
                    q.push(temp);
                }

            }
        }
        return -1;
    }
    void turn(string& s,int x,int y)
    {
        char temp=s[x];
        s[x]=s[y];
        s[y]=temp;
    }
};
```

#### 4.[删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

![image-20201228163914655](https://gitee.com/zisuu/picture/raw/master/img/20201228163914.png)

这题没什么好说的..模板提:

```c++
class Solution {
public:
    vector<string> removeInvalidParentheses(string s) {
        vector<string> result;
        map<string,int> hash;
        queue<string> q;
        q.push(s);
        hash[s]=1;
        while (!q.empty())
        {
            int size=q.size();
            //一层一层遍历
            while(size--)
            {
                string cur=q.front();
                q.pop();
                if(isValid(cur))
                {
                    result.push_back(cur);
                    continue;
                }
                for(int i=0;i<cur.size();i++)
                {
                    if(cur[i]=='('||cur[i]==')')
                    {
                        string temp=reduce(cur,i);
                        if(!hash[temp])
                        {
                            hash[temp]=1;
                            q.push(temp);
                        }
                    }
                }
            }
            //因为题目要求是最小删除数,所以如果一层过后已经有合法的了,就不用再遍历了
            if(result.size())
                return result;
        }
        if(result.size()==0)
            result.push_back("");
        return result;
    }
    /**
     * 删除index下标
     * @param s 
     * @param index 
     * @return 
     */
    string reduce(string  s,int  index)
    {
        string temp;
        temp+=s.substr(0,index);
        temp+=s.substr(index+1,s.length());
        return temp;
    }
    /**
     * 判断是否是合法括号
     * @param s 
     * @return 
     */
    bool isValid(string s)
    {
        int left=0;
        for(auto k:s){
            if(k=='(')
                left++;
            else if(k==')')
            {
                left--;
                if(left<0)
                    return false;
            }
        }
        return left==0;
    }
    
};
```



## 一 拓扑类型

#### [ 1.01 矩阵](https://leetcode-cn.com/problems/01-matrix/)







#### [2. 重新规划路线](https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/)

![image-20201227153104822](https://gitee.com/zisuu/picture/raw/master/img/20201227153104.png)

![image-20201227153112342](https://gitee.com/zisuu/picture/raw/master/img/20201227153112.png)



同样用到前文讲的bfs思想,本题的意思就是,从0开始,往下遍历,观察该边的方向,若方向不是指向0,将错误方向进行扭转即可

实例1很好的解释了这种扭转的过程

```c++
class Solution {
public:
int minReorder(int n, vector<vector<int>>& connections) {
    vector<vector<int>> graph(n,vector<int>());
    //记录每个顶点所拥有的边的索引
    for (int i = 0; i <connections.size() ; ++i) {
        graph[connections[i][0]].push_back(i);
        graph[connections[i][1]].push_back(i);
    }
    vector<bool> flag(n, false);
    queue<int> st;
    st.push(0);
    int ans=0;
    while(!st.empty()){
        auto top=st.front();
        st.pop();
        for(auto k:graph[top]){
            //如果这条边还没被访问
            if(flag[k])continue;
            flag[k]= true;
            int start=connections[k][0];
            int end=connections[k][1];
            //如果start==top,说明边的方向错误,需要扭转
            ans+=(start==top);
            start=(start==top?end:start);
            st.push(start);
        }
    }
    return ans;
}
};
```

