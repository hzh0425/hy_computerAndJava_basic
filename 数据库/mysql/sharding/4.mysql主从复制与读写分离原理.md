## 一、mysql主从复制的工作原理

### 1、mysq支持的复制类型

1）基于语句的复制。在服务器上执行sql语句，在从服务器上执行同样的语句，mysql默认采用基于语句的复制，执行效率高。
2）基于行的复制。把改变的内容复制过去，而不是把命令在从服务器上执行一遍。
3）混合类型的复制。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。

### 2、复制的工作过程

![image-20201229004004244](https://gitee.com/zisuu/picture/raw/master/img/20201229004004.png)

1）在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。
2）Slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，然后开始binlog dump process。binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。
3）Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。

> **简单的说**：就是主服务器上执行过的sql语句会保存在binLog里面，别的从服务器把他同步过来，然后重复执行一遍，那么它们就能一直同步啦。
>
> 我们进一步详细介绍原理的细节， 这有一张图：
>
> ![image-20201229004012449](https://gitee.com/zisuu/picture/raw/master/img/20201229004012.png)
>
> 以上是一个主-从复制（热备)的例子。
>
> 整体上来说，复制有`3`个步骤：
>
> 1. 作为主服务器的Master，会把自己的每一次改动（每条sql语句）都记录到二进制日志Binarylog中。
> 2. 作为从服务器Slave， 会用master上的账号登陆到 master上，读取master的Binarylog,写入到自己的中继日志 Relaylog。
> 3. 然后从服务器自己的sql线程会负责读取这个中继日志，并执行一遍。

### 3、mysql读写分离原理

读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全。

目前较为常见的Mysql读写分离分为两种

1）基于程序代码内部实现
在代码中根据select 、insert进行路由分类，这类方法也是目前生产环境下应用最广泛的。优点是性能较好，因为程序在代码中实现，不需要增加额外的硬件开支，缺点是需要开发人员来实现，运维人员无从下手。

2）基于中间代理层实现
代理一般介于应用服务器和数据库服务器之间，代理数据库服务器接收到应用服务器的请求后根据判断后转发到，后端数据库，有以下代表性的程序。
（1）mysql_proxy。mysql_proxy是Mysql的一个开源项目，通过其自带的lua脚本进行sql判断。
（2）Atlas。是由 Qihoo 360, Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在mysql-proxy 0.8.2版本的基础上，对其进行了优化，增加了一些新的功能特性。360内部使用Atlas运行的mysql业务，每天承载的读写请求数达几十亿条。支持事物以及存储过程。
（3）Amoeba。由阿里巴巴集团在职员工陈思儒使用序java语言进行开发，阿里巴巴集团将其用户生产环境下，但是他并不支持事物以及存数过程。

不是所有的应用都能够在基于程序代码中实现读写分离，像一些大型的java应用，如果在程序代码中实现读写分离对代码的改动就较大，所以，像这种应用一般会考虑使用代理层来实现。